//------------------------- © 1994-1995 by James G. Stout --------------------------// File		: miscCDEF.c// Date		: November 2,1991// Author	: Jim Stout// Purpose	: support routines for CDEFs.//----------------------------------------------------------------------------------#include <Controls.h>#include <Gestalt.h>#include <OSUtils.h>#include <QDOffscreen.h>#include <ToolUtils.h>#include <Traps.h>#include <Types.h>#include "miscCDEF.h"//==================================================================================//	Get the lowest pixel depth of any GDevice for rect 'r'//==================================================================================short getPixDepth(Rect *r){	Rect		gRect, iRect;	GDHandle 	gDev;	short		thisDepth, pixDepth = 32;	GrafPtr		thisPort;		GetPort(&thisPort);	if((thisPort->portBits.rowBytes & 0x8000) == 0)		// b&w port		return(1);		if(!trapAvailable(_GetDeviceList))					// Must have Device Mgr		return(1);										// or we draw in 1 bit mode.			gRect = *r;		LocalToGlobal((Point *)&gRect.top);	LocalToGlobal((Point *)&gRect.bottom);		gDev = GetDeviceList();								// walk device list looking	while(gDev) {										// for lowest pixDepth		if(SectRect(&gRect, &(*gDev)->gdRect, &iRect) &&			TestDeviceAttribute(gDev,screenDevice) &&			TestDeviceAttribute(gDev,screenActive)) {						thisDepth = (*(*gDev)->gdPMap)->pixelSize;			if(thisDepth < pixDepth)				pixDepth = thisDepth;		}		gDev = GetNextDevice(gDev);	}	return(pixDepth);}//==================================================================================//	A "simple minded" version of DeviceLoop that will suffice for these CDEFs//==================================================================================extern void sys6DeviceLoop(RgnHandle drawingRgn, DeviceLoopDrawingUPP drawingProc, 								long userData, DeviceLoopFlags flags){	Rect			gRect, intersect;	GDHandle 		gDev=0;	RgnHandle		oldClip;	short			thisDepth;	devLoopHandle	hDl;	if(trapAvailable(_GetDeviceList)) {						// Must have Device Mgr				oldClip = NewRgn();		GetClip(oldClip);				hDl = (devLoopHandle)userData;				gRect = (**hDl).controlRect;						// need control rect in		LocalToGlobal((Point *)&gRect.top);					// global coords		LocalToGlobal((Point *)&gRect.bottom);				gDev = GetDeviceList();								// walk device list		while(gDev) {										// and find any that															// intersect with control			if(SectRect(&gRect, &(*gDev)->gdRect, &intersect) &&				TestDeviceAttribute(gDev,screenDevice) &&				TestDeviceAttribute(gDev,screenActive)) {								GlobalToLocal((Point *)&intersect.top);				GlobalToLocal((Point *)&intersect.bottom);						ClipRect(&intersect);						// clip to intersection								thisDepth = (*(*gDev)->gdPMap)->pixelSize;								CallDeviceLoopDrawingProc(drawingProc, thisDepth, 0, gDev, userData);			}			gDev = GetNextDevice(gDev);		}		SetClip(oldClip);		DisposeRgn(oldClip);	}	else													// draw 1 bit version		CallDeviceLoopDrawingProc(drawingProc, 1, 0, gDev, userData);}//==================================================================================//	Use Gestalt to find out the MacOS version. //==================================================================================short getOSVers(){	OSErr		err;	short		ret=0x0600;	long		gResult;		if(trapAvailable(_Gestalt)) {						// is Gestalt available ?			err = Gestalt(gestaltSystemVersion,&gResult);		if(err == noErr)			ret = LoWord(gResult);	}	return(ret);}//==================================================================================//	Generic routine to see if a given trap is available//==================================================================================Boolean	trapAvailable(short theTrap){	TrapType	tType;		tType = getTrapType(theTrap);		if(tType == ToolTrap) {		theTrap &= 0x07ff;		if(theTrap >= numToolBoxTraps())			theTrap = _Unimplemented;	}	return(( NGetTrapAddress(theTrap, tType) !=		NGetTrapAddress(_Unimplemented, ToolTrap) ));}//==================================================================================//	Needed for "trapAvailable" routine//==================================================================================TrapType getTrapType(short theTrap){	if((theTrap &= 0x0800))		return(ToolTrap);	return(OSTrap);}//==================================================================================//	Needed for "trapAvailable" routine//==================================================================================short numToolBoxTraps(){	if(NGetTrapAddress(_InitGraf, ToolTrap) ==		NGetTrapAddress(0xaa6e, ToolTrap))		return(0x0200);	return(0x0400);}