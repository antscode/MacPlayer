//------------------------- © 1994-1995 by James G. Stout --------------------------// File		: qdCDEF.c// Purpose	: CDEF quickDraw routines for offScreen drawing and quickdraw version// Date		: 23 June 1992////----------------------------------------------------------------------------------#include <Gestalt.h>#include <Memory.h>#include <OSUtils.h>#include <QDOffscreen.h>#include <ToolUtils.h>#include <Traps.h>#include <Types.h>#include <Windows.h>#include "miscCDEF.h"#include "qdCDEF.h"#define NOPIXELS 0//==================================================================================// Get an offscreen drawing port, either GWorld or Bitmap for specified localRect.// If 32 Bit ColorQuickdraw if found, we try for a GWorld, otherwise, just create// an offscreen bitmap.//// Returns : depth of offPort and a filled in GWorld or Bitmap//==================================================================================extern short getOff(CGrafPtr * offPort, Rect * localRect){	short		wid, ht;	Rect		globalRect;	BitMap		newBits;	QDErr		err;	GrafPtr		savePort;	RgnHandle	grayRgn = GetGrayRgn();	//----------------------------------------------------------------------------------// get an offscreen bitmap/GWorld to minimize flicker when drawing	//----------------------------------------------------------------------------------	if(getQDVers() >= gestalt32BitQD12) {				// try to use a GWorld						globalRect = *localRect;		LocalToGlobal((Point *)&globalRect.top);		LocalToGlobal((Point *)&globalRect.bottom);				if(!RectInRgn(&globalRect, grayRgn))			// avoid crash with v1.2 cQD			return NOPIXELS;					if(*offPort == 0) {								// create a new GWorld							err = NewGWorld((CGrafPtr *)offPort,0,&globalRect,0,0,0);		}		else {											// update existing GWorld						err = UpdateGWorld((CGrafPtr *)offPort,0,&globalRect,0,0,0);		}		if(err == noErr)			return (**((*offPort)->portPixMap)).pixelSize;		return NOPIXELS;								// something is seriously amissÉ		}	else	if(*offPort == 0) {									// create a bitmap							wid = (*localRect).right - (*localRect).left;		ht  = (*localRect).bottom - (*localRect).top;		SetRect(&newBits.bounds,0,0,wid,ht);		newBits.rowBytes = ((wid + 31)/32) * 4;		newBits.baseAddr = NewPtr(ht * newBits.rowBytes);		if(MemError())			return NOPIXELS;			CopyBits(&newBits,&newBits,						// clear the new bitmap									 &newBits.bounds,&newBits.bounds,			 	 srcXor,nil);				 		GetPort(&savePort);		*offPort = (CGrafPtr)NewPtr(sizeof(GrafPort));		if(MemError())			return NOPIXELS;			OpenPort((GrafPtr)*offPort);		SetPort((GrafPtr)*offPort);				(**offPort).portRect = newBits.bounds;		RectRgn((**offPort).visRgn,&newBits.bounds);		SetPortBits(&newBits);		SetPort(savePort);				return 1;	}}//==================================================================================// Lock down the offPort pixels and return a locked handle to the locked pixels//==================================================================================extern PixMapHandle getLockedPixels(CGrafPtr * offPort, short qdVers){	PixMapHandle	pmHdl;		if(qdVers >= gestalt32BitQD13) {					// no bug in the		pmHdl = GetGWorldPixMap(*offPort);				// GetGWorldPixMap routine		if(!LockPixels(pmHdl)) {				pmHdl = 0;		}	}	else		pmHdl = (*offPort)->portPixMap;		if(pmHdl)		HLock((Handle)pmHdl);	return(pmHdl);}//==================================================================================//	Unlock PixMapHandle & pixels//==================================================================================extern void unlockPixels(PixMapHandle pmHdl, short qdVers){		if(pmHdl) {		HUnlock((Handle)pmHdl);		if(qdVers >= gestalt32BitQD13) {				// no bug in the			UnlockPixels(pmHdl);						// GetGWorldPixMap routine		}	}}//==================================================================================//	Return QD version number from Gestalt //==================================================================================short getQDVers()		{	OSErr		err;	long		gResult;		if(trapAvailable(_Gestalt)) {				err = Gestalt(gestaltQuickdrawVersion,&gResult);		if(err == noErr)			return(LoWord(gResult));	}	return(gestaltOriginalQD);}