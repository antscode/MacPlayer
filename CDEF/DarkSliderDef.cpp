//------------------------- © 1995 by James G. Stout -------------------------------//	File	: cdefSlider.c//	Date	: April 8, 1995//	Author	: Jim Stout//			://	Purpose	: A slider CDEF. This supports several appearances via variation codes.//			: The "thumb" is always a square equal to the narrowest axis of scale.//			: Scale colors are taken from 'cctb' cTingeLight and cTingeDark.//			://			: The variations are://			://			:	none					- scale & thumb are the width/height of the//			:							control rect.//			://			:	narrowScale 	0x0001	- scale of slider is 4 pixels smaller than the//			:							the thumb.//			://			:	narrowScale2 	0x0002	- scale of slider is 8 pixels smaller than the//			:							the thumb.//			://			:	filledScale		0x0004	- low end of scale filled with cTingeDark//			://			:	snapToScale		0x0008	- click on scale moves thumb to that point//			://			://			: If you find a use for this, I'd love to know about it.  Bug reports//			: are always interesting.//			://			: Internet    : JimS@WRQ.COM(work hours, PST)//			: AppleLink   : WRQ			(daily)//			: CompuServe  : 73240,2052	(weekly or so)//			: AOL         : JasG		(weekly or so)//			: eWorld      : Jim Stout	(weekly or so)//----------------------------------------------------------------------------------//#define _DEBUGCDEF					// comment this to build CDEF#include <Controls.h>#include <Gestalt.h>#include <Memory.h>#include <QDOffscreen.h>#include <ToolUtils.h>#include <Types.h>#include <Windows.h>#include <MacWindows.h>#include "grayCDEF.h"#include "colorCDEF.h"#include "miscCDEF.h"#include "qdCDEF.h"#include "DarkSliderDef.h"//==================================================================================// CDEF entry point//==================================================================================pascal long DarkSliderDef(short varCode, ControlHandle theCtl, short message, long param){	long	ret = 0L;	SignedByte	cState, dState;		cState = HGetState((Handle)theCtl);	HLock((Handle)theCtl);	if((**theCtl).contrlData) {		dState = HGetState((**theCtl).contrlData);		HLock((**theCtl).contrlData);	}		switch(message) {		case initCntl:			doInit(theCtl);			if((**theCtl).contrlData) {				dState = HGetState((**theCtl).contrlData);				HLock((**theCtl).contrlData);			}		break;		case dispCntl:			doDisp(theCtl);		break;		case drawCntl:			if ((**theCtl).contrlVis != 0 &&				((WindowPeek)(**theCtl).contrlOwner)->visible) {				doDraw(theCtl, varCode);			}		break;		case testCntl:			ret = doTest (theCtl, varCode, param);		break;		case calcCRgns:			RectRgn((RgnHandle)(param & 0x7fffffffL), &(**theCtl).contrlRect);		break;		case calcCntlRgn:		case calcThumbRgn:			RectRgn((RgnHandle)(param), &(**theCtl).contrlRect);		break;	}	if((**theCtl).contrlData)		HSetState((**theCtl).contrlData, dState);	HSetState((Handle)theCtl, cState);	return (ret);}//==================================================================================//	Respond to a "initCntl" message.//	Initialize our control data//==================================================================================static long doInit (ControlHandle theCtl){	short		pDepth;	CDEFHandle	hCDEF;	hCDEF = (CDEFHandle)NewHandle(sizeof(CDEFData));	if(hCDEF) {		(**hCDEF).offPort = 0;		(**hCDEF).qdVers = getQDVers();		(**theCtl).contrlData = (Handle)hCDEF;	}	else		(**theCtl).contrlData = 0;}//==================================================================================//	Respond to a "dispCntl" message.//	Get rid of our control data//==================================================================================static long doDisp		(ControlHandle theCtl){	BitMap		*theBits;	CDEFHandle	hCDEF;		hCDEF = (CDEFHandle)(**theCtl).contrlData;	if(hCDEF) {		if((**hCDEF).offPort) {			if(((**hCDEF).offPort->portVersion & 0x8000) != 0) {	// offPort is GWorld				DisposeGWorld((**hCDEF).offPort);							}			else {													// offport is bitmap				theBits = &((GrafPtr)(**hCDEF).offPort)->portBits;				DisposePtr((*theBits).baseAddr);				ClosePort((GrafPtr)(**hCDEF).offPort);				DisposePtr((Ptr)(**hCDEF).offPort);			}		}					HUnlock((Handle)hCDEF);		DisposeHandle((Handle)hCDEF);		(**theCtl).contrlData = 0;	}}//==================================================================================//	Respond to a "testCntl" message.//	Test to see if the mouse was pressed in the control thumb and drag accordingly//==================================================================================static long doTest (ControlHandle theCtl, short varCode, long param){	Rect		rThumb, rScale;	Point		p;	Boolean 	vert=true;	long		ret = 0;	unsigned long secs;	short		partCode;	CDEFHandle	hCDEF;		hCDEF = (CDEFHandle)(**theCtl).contrlData;	if(!hCDEF)		return(ret);	p.h = LoWord(param);	p.v = HiWord(param);		if(!MacPtInRect(p, &(**theCtl).contrlRect))		return(0);			partCode = (**theCtl).contrlHilite;	rScale = (**theCtl).contrlRect;	if(rScale.right-rScale.left > rScale.bottom-rScale.top)		vert=false;	//----------------------------------------------------------------------------------// get the thumb rect, calculated from control value//----------------------------------------------------------------------------------	getThumbRect(theCtl, &rThumb, &rScale, vert);		if(MacPtInRect(p, &rThumb)) {								// click in thumb?		ret = inThumb;		dragThumb(theCtl, varCode, param);	}	else	if(MacPtInRect(p, &rScale)) {								// click in scale?		if(vert) {			if(p.v < rThumb.top)				ret = inUpScale;							// increase			else			if(p.v > rThumb.bottom)				ret = inDnScale;							// decrease		}		else {			if(p.h < rThumb.left)				ret = inDnScale;							// decrease			else			if(p.h > rThumb.right)				ret = inUpScale;							// increase		}					if(partCode == ret) {			scaleClick(theCtl, varCode, (short)ret, p);			Delay(6L, &secs);		}	}	return(ret);}//==================================================================================// If running with System 7, use DeviceLoop to gracefully handle multiple screens.// Simulate DeviceLoop if using System 6...//==================================================================================static void doDraw(ControlHandle theCtl, short varCode){	short					pixDepth;	devLoopHandle			hDl;	RgnHandle				hRgn;	DeviceLoopDrawingUPP	drawControlUPP;		hDl = (devLoopHandle)NewHandle(sizeof(devLoopData));	if(hDl) {		drawControlUPP = NewDeviceLoopDrawingProc(drawControl);				(**hDl).theCtl = theCtl;		(**hDl).varCode = varCode;		(**hDl).controlRect = (**theCtl).contrlRect;				hRgn = NewRgn();		RectRgn(hRgn, &(**theCtl).contrlRect);				if(getOSVers() >= 0x0700) {			DeviceLoop (hRgn, drawControlUPP, (long)hDl, 0);		}		else {			sys6DeviceLoop (hRgn, drawControlUPP, (long)hDl, 0);		}				DisposeRgn(hRgn);		DisposeHandle((Handle)hDl);		DisposeRoutineDescriptor((UniversalProcPtr)drawControlUPP);	}}//==================================================================================//	Respond to a "drawCntl" message.  The control image is really drawn into an//	offscreen bitmap in "drawParts".  If you want to change the appearance of the//	control, all you have to do is change the drawing routines in "drawParts".//// This is called by DeviceLoop, but in this case, we just pay attention to the// "depth" and "userData" parameters.//==================================================================================pascal void drawControl (short depth, short dFlags, GDHandle theDevice, long userData){	ControlHandle	theCtl;	short			partCode, varCode,pixels;	Rect			rOff,rThumb,rScale;	RgnHandle		clipRgn;	BitMap			*offBits;	PixMapHandle	pmHdl;	CGrafPtr		savePort;	GDHandle		saveGDev;	PenState		savePen;	Boolean			inactive = false, haveGray = false, haveGW = false, inColor = false;	Boolean			vert=true;	RGBColor		saveFore,saveBack;	RGBColor		rgbBlack = {0,0,0};	RGBColor		rgbWhite = {1,1,1}; // AS Commented out: rgbWhite = {-1,-1,-1};		CDEFHandle		hCDEF;								// our private data structures	devLoopHandle	hDl;	//----------------------------------------------------------------------------------// Can we draw?//----------------------------------------------------------------------------------	hDl = (devLoopHandle)userData;						// need control & varCode	if(hDl) {		theCtl = (**hDl).theCtl;		varCode = (**hDl).varCode;	}	else		return;	hCDEF = (CDEFHandle)(**theCtl).contrlData;	if(hCDEF) {		//----------------------------------------------------------------------------------// first, create or update our GWorld	//----------------------------------------------------------------------------------			pixels = getOff(&(**hCDEF).offPort, &(**theCtl).contrlRect);				if(pixels == 0) {								// ohÉ ohÉ							return;												}				if(((**hCDEF).offPort->portVersion & 0x8000) != 0) {	// have a GWorld			haveGW = true;			pmHdl = getLockedPixels(&(**hCDEF).offPort, (**hCDEF).qdVers);			if(!pmHdl)				return;											// nutsÉ		}			rOff = rScale = (**theCtl).contrlRect;		clipRgn = NewRgn();		GetClip(clipRgn);		ClipRect(&rScale);		//----------------------------------------------------------------------------------// Initialize and set for drawing into offScreen port//----------------------------------------------------------------------------------		if((**theCtl).contrlHilite == 0xFF)					// inactive control			inactive = true;					if(depth > 2) {										// save onscreen				inColor = true;									// colors			saveColors(&saveFore, &saveBack);		}				if(haveGW) {										// we have a pixMap					GetGWorld(&savePort, &saveGDev);			SetGWorld((**hCDEF).offPort, nil);			offBits = (BitMap *)*pmHdl;		}		else {												// we have a bitMap				GetPort((GrafPtr*)&savePort);			MacSetPort((GrafPtr)(**hCDEF).offPort);					offBits = (BitMap *)&((GrafPtr)(**hCDEF).offPort)->portBits;		}				if(inColor) {										// need same colors			RGBForeColor(&saveFore);						// offscreen			RGBBackColor(&saveBack);		}		MacOffsetRect(&rOff, - rOff.left, - rOff.top);			// set to (0,0)//----------------------------------------------------------------------------------// draw the control parts into the offscreen port//----------------------------------------------------------------------------------			haveGray = drawParts (theCtl, varCode, inColor, &rOff);		//----------------------------------------------------------------------------------// restore onscreen port & set colors to b&w //----------------------------------------------------------------------------------		if(haveGW) {			SetGWorld(savePort, saveGDev);		} else {			MacSetPort((GrafPtr)savePort);		}		if(inColor) {			RGBForeColor(&rgbBlack);			RGBBackColor(&rgbWhite);		}//----------------------------------------------------------------------------------// now copy it to the onscreen port and restore our colors//----------------------------------------------------------------------------------			CopyBits(offBits,				&((GrafPtr)savePort)->portBits,				&rOff,				&rScale,				srcCopy, nil);				if(haveGW) {			unlockPixels(pmHdl, (**hCDEF).qdVers);		}				if(inColor) {			restoreColors(&saveFore, &saveBack);		}		//----------------------------------------------------------------------------------// if we failed to get an inactive gray color, do it the old way//----------------------------------------------------------------------------------		if(inactive && !haveGray) {							// use the old way of drawing			GetPenState(&savePen);							// an inactive control			PenMode(patBic);			PenPat( (ConstPatternParam) "\xAA\x55\xAA\x55\xAA\x55\xAA\x55");			PaintRect(&(**theCtl).contrlRect);			SetPenState(&savePen);		}		SetClip(clipRgn);		DisposeRgn(clipRgn);	}}//==================================================================================// Respond to a mouse down in our "thumb", track the mouse to reposition the thumb,// set a new control value and call the actionProc (if any).//==================================================================================static void dragThumb (ControlHandle theCtl, short varCode, long param){	short	newVal,maxDrag,minDrag;	Rect	rThumb, rScale;	Point	p,oldPt;	Boolean	vert=true;	rScale = (**theCtl).contrlRect;	if(rScale.right-rScale.left > rScale.bottom-rScale.top)		vert=false;			getThumbRect(theCtl, &rThumb, &rScale, vert);		p.h = oldPt.h = LoWord(param);	p.v = oldPt.v = HiWord(param);		if(MacPtInRect(p, &rThumb)) {		if(vert) {			maxDrag = rScale.bottom - (rThumb.bottom - p.v);			minDrag = rScale.top + (p.v - rThumb.top);						while (StillDown()) {				if(oldPt.v != p.v) {							// mouse moved					MacOffsetRect(&rThumb, 0, (p.v-oldPt.v));		// move the thumb						checkLimits(vert, &rThumb, &rScale);		// but not too farÉ										newVal = getNewValue(theCtl, vert, rScale.bottom - rThumb.bottom);										if(newVal != (**theCtl).contrlValue) {						adjustControl(theCtl, varCode, inThumb, newVal);					}					if(p.v > minDrag && p.v < maxDrag)			// track move						oldPt.v = p.v;					}				GetMouse(&p);			}		}		else {						maxDrag = rScale.right - (rThumb.right - p.h);			minDrag = rScale.left + (p.h - rThumb.left);			while (StillDown()) {				if(oldPt.h != p.h) {							// mouse moved					MacOffsetRect(&rThumb, (p.h-oldPt.h), 0);		// move the thumb						checkLimits(vert, &rThumb, &rScale);		// but not too farÉ					newVal = getNewValue(theCtl, vert, rThumb.left - rScale.left);														if(newVal != (**theCtl).contrlValue) {						adjustControl(theCtl, varCode, inThumb, newVal);					}					if(p.h > minDrag && p.h < maxDrag)			// track move						oldPt.h = p.h;					}				GetMouse(&p);			}		}	}}//==================================================================================// Adjust the control after detecting a click in the scale instead of the thumb -// set a new control value and call the actionProc (if any).//==================================================================================static void scaleClick (ControlHandle theCtl, short varCode, short partCode, Point p){	short	newVal,incr=1,thumbSize;	Rect	rThumb,rScale;	Boolean	vert=true;			newVal = (**theCtl).contrlValue;	if(varCode & snapToScale) {		rScale = (**theCtl).contrlRect;		if(rScale.right-rScale.left > rScale.bottom-rScale.top)			vert=false;		getThumbRect(theCtl, &rThumb, &rScale, vert);		thumbSize = rThumb.right - rThumb.left;				if(vert) {			if(partCode == inUpScale) {				rThumb.top = p.v - thumbSize/2;				rThumb.bottom = rThumb.top + thumbSize;			}			else {				rThumb.bottom = p.v + thumbSize/2;				rThumb.top = rThumb.bottom - thumbSize;			}				checkLimits(vert, &rThumb, &rScale);		// don't move too farÉ										newVal = getNewValue(theCtl, vert, rScale.bottom - rThumb.bottom);		}		else {			if(partCode == inUpScale) {				rThumb.left = p.h - thumbSize/2;				rThumb.right = rThumb.left + thumbSize;			}			else {				rThumb.right = p.h + thumbSize/2;				rThumb.left = rThumb.right - thumbSize;			}			checkLimits(vert, &rThumb, &rScale);		// don't move too farÉ						newVal = getNewValue(theCtl, vert, rThumb.left - rScale.left);		}	}	else {		if((**theCtl).contrlMin > (**theCtl).contrlMax)			incr = -1;			if(partCode == inDnScale)						// decrease value by 1			newVal-=incr;		else 		if(partCode == inUpScale)						// increase value by 1			newVal+=incr;			}	if(newVal != (**theCtl).contrlValue) {		adjustControl(theCtl, varCode, partCode, newVal);	}}//==================================================================================//	Calculate & position the thumbRect at the proper point on the scale//==================================================================================static void getThumbRect(ControlHandle theCtl, Rect *rThumb, 							Rect *rScale, Boolean vert){	short	thumbSize,thumbOff;		*rThumb = *rScale;		if(vert) {		thumbSize = rThumb->right-rThumb->left;		rThumb->top = rThumb->bottom-thumbSize;		thumbOff = getThumbOffset(theCtl, vert, thumbSize);		MacOffsetRect(rThumb, 0, - thumbOff);	}	else {		thumbSize = rThumb->bottom-rThumb->top;		rThumb->right = rThumb->left+thumbSize;		thumbOff = getThumbOffset(theCtl, vert, thumbSize);		MacOffsetRect(rThumb, thumbOff, 0);	}}//==================================================================================//	Calculate the offset of the thumb from the low end of the scale//==================================================================================static short getThumbOffset	(ControlHandle theCtl, Boolean vert, short thumbSize){	float	scale, range, nullPos;		if(vert)		scale = (**theCtl).contrlRect.bottom - (**theCtl).contrlRect.top - thumbSize;	else		scale = (**theCtl).contrlRect.right - (**theCtl).contrlRect.left - thumbSize;		range = (**theCtl).contrlMax - (**theCtl).contrlMin;		nullPos = (-1 * (**theCtl).contrlMin / range) * scale;		return((**theCtl).contrlValue * scale/range + nullPos);}//==================================================================================//	Insure that the thumb has not moved off the scale//==================================================================================static short checkLimits	(Boolean vert, Rect *rThumb, Rect *rScale){	if(vert) {		if(rThumb->top < rScale->top)					// pin to top of scale			MacOffsetRect(rThumb, 0, rScale->top - rThumb->top); 		else		if(rThumb->bottom > rScale->bottom)			// pin to bottom of scale			MacOffsetRect(rThumb, 0, rScale->bottom - rThumb->bottom); 	}	else {		if(rThumb->left < rScale->left) {			// pin to left of scale			MacOffsetRect(rThumb, rScale->left - rThumb->left, 0); 		}		else		if(rThumb->right > rScale->right) {			// pin to right of scale			MacOffsetRect(rThumb, rScale->right - rThumb->right, 0); 		}	}}//==================================================================================//	Calculate the value of the control from the thumb position//==================================================================================static short getNewValue	(ControlHandle theCtl, Boolean vert, short thumbOff){	short	thumbSize;	float	scale, range, nullPos;			if(vert) {		thumbSize = (**theCtl).contrlRect.right - (**theCtl).contrlRect.left;		scale = (**theCtl).contrlRect.bottom - (**theCtl).contrlRect.top - thumbSize;	}	else {		thumbSize = (**theCtl).contrlRect.bottom - (**theCtl).contrlRect.top;		scale = (**theCtl).contrlRect.right - (**theCtl).contrlRect.left - thumbSize;	}		range = (**theCtl).contrlMax - (**theCtl).contrlMin;		nullPos = (-1 * (**theCtl).contrlMin / range) * scale;		return((thumbOff - nullPos) * range/scale);}//==================================================================================//	Adjust control to reflect new thumb postion, draw it and call actionProc//==================================================================================static void adjustControl(ControlHandle theCtl, short varCode,							short partCode, short newVal){	(**theCtl).contrlValue = newVal;	doDraw(theCtl, varCode);	if((**theCtl).contrlAction != nil)		CallControlActionProc((**theCtl).contrlAction, theCtl, partCode);}//==================================================================================//	Do the actual drawing of the scale and thumb into an offscreen port for use by//	the doDraw routine above. The offscreen port has been prepared and is set for//	drawing when this routine is called. ////	Change this to customize the control appearance.//==================================================================================static Boolean drawParts (ControlHandle theCtl, short varCode, Boolean inColor,							Rect *rOff){	short		mid,inx;	Rect		rThumb, rScale,rFilled,r;	Boolean		haveGray = false, vert = true;	RGBColor	saveFore,saveBack,rgbE={0xeeee,0xeeee,0xeeee};	RGBColor	frameGray1,frameGray2;	CDEFHandle	hCDEF;		hCDEF = (CDEFHandle)(**theCtl).contrlData;	if(hCDEF) {	//----------------------------------------------------------------------------------//	Initialize drawing rects//----------------------------------------------------------------------------------		if(rOff->right-rOff->left > rOff->bottom-rOff->top)			vert=false;				rScale = *rOff;									// get part rects		getThumbRect(theCtl, &rThumb, rOff, vert);				EraseRect(&rScale);								// erase to port bg color		EraseRect(&rThumb);			if(varCode & narrowScale) {						// adjust scale size			if(vert)				MacInsetRect(&rScale, 2, 0);			else				MacInsetRect(&rScale, 0, 2);		}		if(varCode & narrowScale2) {			if(vert)				MacInsetRect(&rScale, 4, 0);			else				MacInsetRect(&rScale, 0, 4);		}				rFilled = rScale;		if(vert)			rFilled.top = rThumb.bottom;		else			rFilled.right = rThumb.left;		//----------------------------------------------------------------------------------// set up drawing colors//----------------------------------------------------------------------------------	  	if(inColor) {	  		inColor = true;	  		saveColors(&saveFore, &saveBack);			// save current colors	  		setPartColor(theCtl, cFrameColor, true);	// set fg 'cctb' Color	  		setPartColor(theCtl, cTingeLight, false);	// set bg 'cctb' Color	  			  		if(getGray(&frameGray1)) {					// get grays for the	  			haveGray = true;						// inactive control frame	  			RGBForeColor(&frameGray1);				// or 3D shadow	  		}	  		getGray(&frameGray2);	  		setPartColor(theCtl, cFrameColor, true);	  	}		//----------------------------------------------------------------------------------// draw the scale body//----------------------------------------------------------------------------------				EraseRect(&rScale);				if(varCode & filledScale) {			if(inColor) {				setPartColor(theCtl, cTingeDark, false);				EraseRect(&rFilled);				setPartColor(theCtl, cTingeLight, false);			}			else				PaintRect(&rFilled);		}		//----------------------------------------------------------------------------------// draw the scale frame//----------------------------------------------------------------------------------										if((**theCtl).contrlHilite == 0xFF) {			// inactive control, so set			if(haveGray)								// to a grayed fg color				RGBForeColor(&frameGray1);		}				short innerRectPos = (rScale.bottom - rScale.top - 2) / 2;		Rect leftRounded;		MacSetRect(&leftRounded, rScale.left, innerRectPos, rScale.left + 4, innerRectPos + 4);		FillOval(&leftRounded, &qd.black);		Rect innerRect;		MacSetRect(&innerRect, rScale.left + 2, innerRectPos, rScale.right - 2, innerRectPos + 4);		MacFillRect(&innerRect, &qd.black);		Rect rightRounded;		MacSetRect(&rightRounded, rScale.right - 4, innerRectPos, rScale.right, innerRectPos + 4);		FillOval(&rightRounded, &qd.black);		//MacFrameRect(&rScale);								// frame scale in fg color		//			//if(inColor) {									// get gray for 3D "dark"		//	RGBForeColor(&frameGray2);					// shadow		//}						//MoveTo(rScale.left+1,rScale.bottom-2);			// "dark" shadow along left		//MacLineTo(rScale.left+1,rScale.top+1);				// and top edges		//MacLineTo(rScale.right-2, rScale.top+1);		//			//if(inColor) {		//	ForeColor(whiteColor);						// "light" shadow along right		//	Move(0, 1);									// and bottom edges		//	MacLineTo(rScale.right-2, rScale.bottom-2);		//	MacLineTo(rScale.left+2, rScale.bottom-2);		//}		//----------------------------------------------------------------------------------// draw the thumb//----------------------------------------------------------------------------------				if(inColor) {			setPartColor(theCtl, cFrameColor, true);			RGBBackColor(&rgbE);		}		else			ForeColor(blackColor);					if((**theCtl).contrlHilite == 0xFF) {			// inactive control, so set			if(inColor)				RGBForeColor(&frameGray1);				// a grayed fg color		}		FillOval(&rThumb, &qd.black);		PenPat(&qd.white);		FrameOval(&rThumb);				//MacInsetRect(&rThumb, 1, 1);						// erase interior of		//EraseRect(&rThumb);								// thumb		//MacInsetRect(&rThumb, -1, -1);//----------------------------------------------------------------------------------// if scale is narrower than thumb, don't draw the corners of the thumb frame//----------------------------------------------------------------------------------//  		if(varCode & narrowScale || varCode & narrowScale2) {//			MoveTo(rThumb.left, rThumb.bottom-2);//			MacLineTo(rThumb.left, rThumb.top+1);//			Move(1,-1);//			MacLineTo(rThumb.right-2, rThumb.top);//			Move(1,1);//			MacLineTo(rThumb.right-1, rThumb.bottom-2);//			Move(-1,1);//			MacLineTo(rThumb.left+1, rThumb.bottom-1);//		}//		else//			MacFrameRect(&rThumb);							// full frame in fg color//	//		if(inColor) {									// get gray for 3D dark//			getGray(&frameGray2);						// shadow//			RGBForeColor(&frameGray2);//		}//		////----------------------------------------------------------------------------------//// draw shadowed frame for thumb////----------------------------------------------------------------------------------////		MoveTo(rThumb.left+1, rThumb.bottom-2);			// dark shadow//		MacLineTo(rThumb.right-2, rThumb.bottom-2);//		MacLineTo(rThumb.right-2, rThumb.top+1);//			//		if(inColor) {//			ForeColor(whiteColor);						// light shadow//			Move(-1, 0);//			MacLineTo(rThumb.left+1, rThumb.top+1);//			MacLineTo(rThumb.left+1, rThumb.bottom-3);//		}//		////----------------------------------------------------------------------------------//// draw indicator line in center of thumb - first the light shadow////----------------------------------------------------------------------------------//		if(vert)//			mid = rThumb.top + (rThumb.bottom-rThumb.top)/2 - 1;//		else//			mid = rThumb.left + (rThumb.right-rThumb.left)/2 - 1;//			//		if(inColor) {//			if(vert) {//				MoveTo(rThumb.left+1, mid+1);//				MacLineTo(rThumb.right-3, mid+1);//			}//			else {//				MoveTo(mid+1, rThumb.top+1);//				MacLineTo(mid+1, rThumb.bottom-3);//			}//		}//	////----------------------------------------------------------------------------------//// draw indicator line in center of thumb - now the dark shadow////----------------------------------------------------------------------------------////		if(inColor)//			RGBForeColor(&frameGray1);//		else//			ForeColor(blackColor);//			//		if(vert) {//			MoveTo(rThumb.left+1, mid);//			MacLineTo(rThumb.right-3, mid);//		}//		else {//			MoveTo(mid, rThumb.top+1);//			MacLineTo(mid, rThumb.bottom-3);//		}	//----------------------------------------------------------------------------------// Done drawing - restore colors and exit//----------------------------------------------------------------------------------	  	if(inColor) {	  		restoreColors(&saveFore, &saveBack);	  	}  	}  	return(haveGray);}